This course lays the foundations for the understanding of CPU architectures, networking and operating systems. Additionally, it introduces topics which cut across many computer systems, such as cross-layer communication and basic concurrency (as well as basic ideas of virtualization and efficiency through proximity).
CPU architectures are discussed from first principles (digital logic) and are expanded into current day designs. This also involves assembler level programming to connect hardware circuits to the world of software. Representations of data types and high-level code at the machine level will be made clear by keeping the relations between high-level and machine-level code throughout the course. It will also look at how concurrent software constructs can or cannot be translated into parallel hardware operations.
This course will cover a wide range of topics such as digital logic: transistors, gates, and combinatorial circuits; clocks; registers and register banks; arithmetic-logic units; data representation: big-endian and littleendian integers; ones and twos complement arithmetic; signed and unsigned values; Von-Neumann architecture and bottleneck; instruction sets; RISC and CISC designs; instruction pipelines and stalls; rearranging code; memory and address spaces; physical and virtual memory; interleaving; page tables; memory caches; bus architecture; polling and interrupts; DMA; device programming; assembly language; optimizations; concurrency and parallelism; and data pipelining.
Knowledge of the principles of networking and operating systems (as well as their relation to computer hardware) are essential for every computer scientist and this course will provide those foundations.
The relation of assembler level building blocks (macros) to constructs in direct compiled language is demonstrated throughout the course.
Describe the layers of architectures in computer systems from digital logic to networks.
Explain how the major components of a CPU are composed (in terms of digital logic) and work together (including how data is represented on a computer).
Design, implement and analyse programs in assembly language, including basic synchronization, I/O and interrupt techniques.
Describe the relationship between high-level languages and assembly languages, including function calls and basic control structures.
Demonstrate foundational knowledge about operating systems and networks.
Express simple conditional and functional decomposition in a basic, direct compiled language (such as C).
Connect conceptually hardware and software aspects of computer systems.
Demonstrate the ability to migrate between all essential abstraction levels when discussing computer systems design, ranging from a software oriented view all the way through to individual digital circuits.
Demonstrate a well founded understanding of the implications of machine level choices on efficiency and predictability in the context of the hardware architectures covered in the course.