score,s1,s2
0.8241,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.",This course is the first of three core computer science courses on programming.
0.8317,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.","Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8451,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.",Understand basic types and the benefits of static typing.
0.8480,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.","Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8500,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.","The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8508,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.","Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8557,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.","Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8580,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.","Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8589,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.",The functional paradigm demonstrates elegant solutions to many programming problems.
0.8601,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.","The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8604,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.","The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.8605,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.","Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8610,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.",Understand the legal context for protection of software as intellectual property.
0.8611,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.",These include distributed software revision control systems.
0.8636,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.",The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.8659,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.","Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8664,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.","Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8665,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.","Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8797,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.",Describe and apply alternative computational paradigms to simple problems.
0.8854,"Society relies on many complex systems of interacting technology, people, processes, laws and other elements. Examples of such systems include air transport, telecommunications and energy supply.",It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.8384,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.","Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8429,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.","Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8530,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.","Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8734,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.",Understand basic types and the benefits of static typing.
0.8751,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.","Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8786,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.",These include distributed software revision control systems.
0.8797,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.","Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8797,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.","Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8857,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.",This course is the first of three core computer science courses on programming.
0.8857,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.","Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8927,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.","The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8939,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.",Understand the legal context for protection of software as intellectual property.
0.8992,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.",The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.9009,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.",The functional paradigm demonstrates elegant solutions to many programming problems.
0.9035,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.","The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.9047,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.","Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.9063,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.","The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.9090,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.","Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.9146,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.",Describe and apply alternative computational paradigms to simple problems.
0.9318,"Systems Engineering is a holistic, multi-disciplinary and well established approach to the engineering of these complex systems.",It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.8343,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.","Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8468,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.","Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8571,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.","Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8580,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.","Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8683,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.","The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8691,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.",Understand basic types and the benefits of static typing.
0.8701,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.","Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8729,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.","Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8805,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.",This course is the first of three core computer science courses on programming.
0.8875,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.","The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.8878,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.","Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8972,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.",The functional paradigm demonstrates elegant solutions to many programming problems.
0.8977,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.",Understand the legal context for protection of software as intellectual property.
0.8990,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.",Describe and apply alternative computational paradigms to simple problems.
0.8992,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.","The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.9032,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.",The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.9045,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.","Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.9061,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.",These include distributed software revision control systems.
0.9096,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.","Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.9208,"Because software is a critical component of such systems, Software Engineers will often work in Systems Engineering teams.",It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.8368,Systems concepts.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8372,Systems concepts.,"Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8373,Systems concepts.,"Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8385,Systems concepts.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8420,Systems concepts.,"Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8429,Systems concepts.,"Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8516,Systems concepts.,"Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8527,Systems concepts.,"Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8620,Systems concepts.,It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.8620,Systems concepts.,The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.8675,Systems concepts.,This course is the first of three core computer science courses on programming.
0.8766,Systems concepts.,Understand the legal context for protection of software as intellectual property.
0.8809,Systems concepts.,"Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8823,Systems concepts.,"The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.8851,Systems concepts.,"Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8914,Systems concepts.,"The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8915,Systems concepts.,These include distributed software revision control systems.
0.8960,Systems concepts.,Understand basic types and the benefits of static typing.
0.8975,Systems concepts.,The functional paradigm demonstrates elegant solutions to many programming problems.
0.9092,Systems concepts.,Describe and apply alternative computational paradigms to simple problems.
0.8442,The Systems Engineering life-cycle and processes.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8450,The Systems Engineering life-cycle and processes.,"Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8467,The Systems Engineering life-cycle and processes.,"Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8488,The Systems Engineering life-cycle and processes.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8542,The Systems Engineering life-cycle and processes.,"Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8549,The Systems Engineering life-cycle and processes.,"Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8668,The Systems Engineering life-cycle and processes.,This course is the first of three core computer science courses on programming.
0.8724,The Systems Engineering life-cycle and processes.,"Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8758,The Systems Engineering life-cycle and processes.,"The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.8802,The Systems Engineering life-cycle and processes.,The functional paradigm demonstrates elegant solutions to many programming problems.
0.8813,The Systems Engineering life-cycle and processes.,Understand basic types and the benefits of static typing.
0.8822,The Systems Engineering life-cycle and processes.,"Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8824,The Systems Engineering life-cycle and processes.,"Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8829,The Systems Engineering life-cycle and processes.,"Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8869,The Systems Engineering life-cycle and processes.,Understand the legal context for protection of software as intellectual property.
0.8870,The Systems Engineering life-cycle and processes.,The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.8872,The Systems Engineering life-cycle and processes.,These include distributed software revision control systems.
0.8874,The Systems Engineering life-cycle and processes.,It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.8949,The Systems Engineering life-cycle and processes.,"The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.9011,The Systems Engineering life-cycle and processes.,Describe and apply alternative computational paradigms to simple problems.
0.8511,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.",This course is the first of three core computer science courses on programming.
0.8694,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.","The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8767,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.",These include distributed software revision control systems.
0.8780,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.",Understand the legal context for protection of software as intellectual property.
0.8836,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.","Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8881,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.",Understand basic types and the benefits of static typing.
0.8908,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.","Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8941,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.","Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8953,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.",The functional paradigm demonstrates elegant solutions to many programming problems.
0.8988,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.",It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.9005,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.",The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.9034,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.","Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.9050,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.","Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.9057,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.","The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.9108,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.","The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.9128,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.","Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.9147,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.",Describe and apply alternative computational paradigms to simple problems.
0.9158,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.","Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.9240,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.","Describe, understand and evolve programs, via documentation, testing, and debugging."
0.9322,"Conceptual system design: including problem definition, technical performance measures, quality function deployment (QFD), trade-off analyses, and system specification.","Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8337,"Preliminary system design: subsystem design requirements, design review.","The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8425,"Preliminary system design: subsystem design requirements, design review.",This course is the first of three core computer science courses on programming.
0.8451,"Preliminary system design: subsystem design requirements, design review.","Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8486,"Preliminary system design: subsystem design requirements, design review.","Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8525,"Preliminary system design: subsystem design requirements, design review.","Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8533,"Preliminary system design: subsystem design requirements, design review.","Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8561,"Preliminary system design: subsystem design requirements, design review.","Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8594,"Preliminary system design: subsystem design requirements, design review.",Understand basic types and the benefits of static typing.
0.8595,"Preliminary system design: subsystem design requirements, design review.","Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8614,"Preliminary system design: subsystem design requirements, design review.",Understand the legal context for protection of software as intellectual property.
0.8659,"Preliminary system design: subsystem design requirements, design review.",It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.8680,"Preliminary system design: subsystem design requirements, design review.","Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8688,"Preliminary system design: subsystem design requirements, design review.",The functional paradigm demonstrates elegant solutions to many programming problems.
0.8703,"Preliminary system design: subsystem design requirements, design review.","The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.8707,"Preliminary system design: subsystem design requirements, design review.",The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.8778,"Preliminary system design: subsystem design requirements, design review.",These include distributed software revision control systems.
0.8803,"Preliminary system design: subsystem design requirements, design review.","The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8803,"Preliminary system design: subsystem design requirements, design review.","Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8865,"Preliminary system design: subsystem design requirements, design review.","Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8883,"Preliminary system design: subsystem design requirements, design review.",Describe and apply alternative computational paradigms to simple problems.
0.8399,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.",This course is the first of three core computer science courses on programming.
0.8594,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.","Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8613,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.",Understand the legal context for protection of software as intellectual property.
0.8635,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.",These include distributed software revision control systems.
0.8711,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.","The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8767,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.","Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8793,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.",The functional paradigm demonstrates elegant solutions to many programming problems.
0.8796,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.","Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8831,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.","Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8836,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.","Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8849,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.",It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.8879,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.","Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8891,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.","The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8894,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.",Understand basic types and the benefits of static typing.
0.8912,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.","Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8933,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.","The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.8989,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.",The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.9064,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.",Describe and apply alternative computational paradigms to simple problems.
0.9113,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.","Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.9187,"Detailed design and development: Detailed design requirements and design engineering activities; review and feedback, and incorporation of design changes.","Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8270,"Design testing, evaluation and validation.","Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8330,"Design testing, evaluation and validation.","Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8340,"Design testing, evaluation and validation.","The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8344,"Design testing, evaluation and validation.","Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8347,"Design testing, evaluation and validation.",This course is the first of three core computer science courses on programming.
0.8371,"Design testing, evaluation and validation.","Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8478,"Design testing, evaluation and validation.","Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8513,"Design testing, evaluation and validation.",The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.8549,"Design testing, evaluation and validation.",It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.8550,"Design testing, evaluation and validation.",Understand the legal context for protection of software as intellectual property.
0.8565,"Design testing, evaluation and validation.","The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.8592,"Design testing, evaluation and validation.","Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8592,"Design testing, evaluation and validation.",The functional paradigm demonstrates elegant solutions to many programming problems.
0.8594,"Design testing, evaluation and validation.",Understand basic types and the benefits of static typing.
0.8598,"Design testing, evaluation and validation.","Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8621,"Design testing, evaluation and validation.","The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8628,"Design testing, evaluation and validation.","Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8672,"Design testing, evaluation and validation.",These include distributed software revision control systems.
0.8759,"Design testing, evaluation and validation.",Describe and apply alternative computational paradigms to simple problems.
0.9046,"Design testing, evaluation and validation.","Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8352,Design for sustainability: approaches that integrate sustainability principles into the design process.,"Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8474,Design for sustainability: approaches that integrate sustainability principles into the design process.,"Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8502,Design for sustainability: approaches that integrate sustainability principles into the design process.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8581,Design for sustainability: approaches that integrate sustainability principles into the design process.,"Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8667,Design for sustainability: approaches that integrate sustainability principles into the design process.,"Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8674,Design for sustainability: approaches that integrate sustainability principles into the design process.,This course is the first of three core computer science courses on programming.
0.8691,Design for sustainability: approaches that integrate sustainability principles into the design process.,These include distributed software revision control systems.
0.8717,Design for sustainability: approaches that integrate sustainability principles into the design process.,"Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8768,Design for sustainability: approaches that integrate sustainability principles into the design process.,Understand basic types and the benefits of static typing.
0.8828,Design for sustainability: approaches that integrate sustainability principles into the design process.,"Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8837,Design for sustainability: approaches that integrate sustainability principles into the design process.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8920,Design for sustainability: approaches that integrate sustainability principles into the design process.,"Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8992,Design for sustainability: approaches that integrate sustainability principles into the design process.,"The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8995,Design for sustainability: approaches that integrate sustainability principles into the design process.,Understand the legal context for protection of software as intellectual property.
0.9002,Design for sustainability: approaches that integrate sustainability principles into the design process.,The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.9058,Design for sustainability: approaches that integrate sustainability principles into the design process.,The functional paradigm demonstrates elegant solutions to many programming problems.
0.9081,Design for sustainability: approaches that integrate sustainability principles into the design process.,"The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.9138,Design for sustainability: approaches that integrate sustainability principles into the design process.,"Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.9168,Design for sustainability: approaches that integrate sustainability principles into the design process.,It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.9182,Design for sustainability: approaches that integrate sustainability principles into the design process.,Describe and apply alternative computational paradigms to simple problems.
0.8135,Integration of Systems Engineering and Software Engineering activities.,"Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8286,Integration of Systems Engineering and Software Engineering activities.,"Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8355,Integration of Systems Engineering and Software Engineering activities.,"Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8406,Integration of Systems Engineering and Software Engineering activities.,"Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8412,Integration of Systems Engineering and Software Engineering activities.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8431,Integration of Systems Engineering and Software Engineering activities.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8543,Integration of Systems Engineering and Software Engineering activities.,Understand basic types and the benefits of static typing.
0.8553,Integration of Systems Engineering and Software Engineering activities.,"Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8655,Integration of Systems Engineering and Software Engineering activities.,"Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8716,Integration of Systems Engineering and Software Engineering activities.,The functional paradigm demonstrates elegant solutions to many programming problems.
0.8738,Integration of Systems Engineering and Software Engineering activities.,"The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.8792,Integration of Systems Engineering and Software Engineering activities.,This course is the first of three core computer science courses on programming.
0.8799,Integration of Systems Engineering and Software Engineering activities.,"Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8804,Integration of Systems Engineering and Software Engineering activities.,Understand the legal context for protection of software as intellectual property.
0.8837,Integration of Systems Engineering and Software Engineering activities.,These include distributed software revision control systems.
0.8844,Integration of Systems Engineering and Software Engineering activities.,"The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8869,Integration of Systems Engineering and Software Engineering activities.,"Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8871,Integration of Systems Engineering and Software Engineering activities.,Describe and apply alternative computational paradigms to simple problems.
0.8883,Integration of Systems Engineering and Software Engineering activities.,The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.9007,Integration of Systems Engineering and Software Engineering activities.,It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.8415,describe the holistic and multi-disciplinary nature of complex engineering projects.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8569,describe the holistic and multi-disciplinary nature of complex engineering projects.,"Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8573,describe the holistic and multi-disciplinary nature of complex engineering projects.,"Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8696,describe the holistic and multi-disciplinary nature of complex engineering projects.,"Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8697,describe the holistic and multi-disciplinary nature of complex engineering projects.,This course is the first of three core computer science courses on programming.
0.8718,describe the holistic and multi-disciplinary nature of complex engineering projects.,"Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8857,describe the holistic and multi-disciplinary nature of complex engineering projects.,These include distributed software revision control systems.
0.8858,describe the holistic and multi-disciplinary nature of complex engineering projects.,"Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8859,describe the holistic and multi-disciplinary nature of complex engineering projects.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8868,describe the holistic and multi-disciplinary nature of complex engineering projects.,"Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8899,describe the holistic and multi-disciplinary nature of complex engineering projects.,Understand basic types and the benefits of static typing.
0.8902,describe the holistic and multi-disciplinary nature of complex engineering projects.,"Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8923,describe the holistic and multi-disciplinary nature of complex engineering projects.,The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.8978,describe the holistic and multi-disciplinary nature of complex engineering projects.,Understand the legal context for protection of software as intellectual property.
0.8986,describe the holistic and multi-disciplinary nature of complex engineering projects.,"Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.9015,describe the holistic and multi-disciplinary nature of complex engineering projects.,"The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.9048,describe the holistic and multi-disciplinary nature of complex engineering projects.,"The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.9071,describe the holistic and multi-disciplinary nature of complex engineering projects.,The functional paradigm demonstrates elegant solutions to many programming problems.
0.9081,describe the holistic and multi-disciplinary nature of complex engineering projects.,It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.9251,describe the holistic and multi-disciplinary nature of complex engineering projects.,Describe and apply alternative computational paradigms to simple problems.
0.8135,describe the Systems Engineering life-cycle.,"Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8194,describe the Systems Engineering life-cycle.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8206,describe the Systems Engineering life-cycle.,"Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8329,describe the Systems Engineering life-cycle.,"Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8361,describe the Systems Engineering life-cycle.,"Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8431,describe the Systems Engineering life-cycle.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8505,describe the Systems Engineering life-cycle.,"Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8633,describe the Systems Engineering life-cycle.,"The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.8680,describe the Systems Engineering life-cycle.,"Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8684,describe the Systems Engineering life-cycle.,This course is the first of three core computer science courses on programming.
0.8707,describe the Systems Engineering life-cycle.,The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.8743,describe the Systems Engineering life-cycle.,"Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8765,describe the Systems Engineering life-cycle.,Understand basic types and the benefits of static typing.
0.8799,describe the Systems Engineering life-cycle.,It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.8802,describe the Systems Engineering life-cycle.,The functional paradigm demonstrates elegant solutions to many programming problems.
0.8832,describe the Systems Engineering life-cycle.,"Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8875,describe the Systems Engineering life-cycle.,"The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8911,describe the Systems Engineering life-cycle.,Describe and apply alternative computational paradigms to simple problems.
0.8919,describe the Systems Engineering life-cycle.,Understand the legal context for protection of software as intellectual property.
0.8919,describe the Systems Engineering life-cycle.,These include distributed software revision control systems.
0.8256,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,"Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8283,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,"Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8284,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8427,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,"Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8515,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,"Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8577,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,"Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8592,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,Understand basic types and the benefits of static typing.
0.8621,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,This course is the first of three core computer science courses on programming.
0.8622,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,These include distributed software revision control systems.
0.8649,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8687,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,The functional paradigm demonstrates elegant solutions to many programming problems.
0.8708,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,"The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.8753,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,"Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8758,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,"Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8813,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,Understand the legal context for protection of software as intellectual property.
0.8834,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,"The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8870,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.8877,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,"Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8915,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,Describe and apply alternative computational paradigms to simple problems.
0.8920,identify and explain the activities involved in each phase of the Systems Engineering life-cycle.,It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.8220,explain the role of Software Engineering within the broader context of Systems Engineering.,"Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8370,explain the role of Software Engineering within the broader context of Systems Engineering.,"Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8424,explain the role of Software Engineering within the broader context of Systems Engineering.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8441,explain the role of Software Engineering within the broader context of Systems Engineering.,"Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8509,explain the role of Software Engineering within the broader context of Systems Engineering.,"Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8587,explain the role of Software Engineering within the broader context of Systems Engineering.,"Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8635,explain the role of Software Engineering within the broader context of Systems Engineering.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8649,explain the role of Software Engineering within the broader context of Systems Engineering.,"Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8732,explain the role of Software Engineering within the broader context of Systems Engineering.,These include distributed software revision control systems.
0.8748,explain the role of Software Engineering within the broader context of Systems Engineering.,Understand basic types and the benefits of static typing.
0.8859,explain the role of Software Engineering within the broader context of Systems Engineering.,The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.8860,explain the role of Software Engineering within the broader context of Systems Engineering.,The functional paradigm demonstrates elegant solutions to many programming problems.
0.8863,explain the role of Software Engineering within the broader context of Systems Engineering.,This course is the first of three core computer science courses on programming.
0.8946,explain the role of Software Engineering within the broader context of Systems Engineering.,Describe and apply alternative computational paradigms to simple problems.
0.8963,explain the role of Software Engineering within the broader context of Systems Engineering.,"The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.8999,explain the role of Software Engineering within the broader context of Systems Engineering.,"Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.9063,explain the role of Software Engineering within the broader context of Systems Engineering.,"The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.9065,explain the role of Software Engineering within the broader context of Systems Engineering.,Understand the legal context for protection of software as intellectual property.
0.9096,explain the role of Software Engineering within the broader context of Systems Engineering.,"Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.9228,explain the role of Software Engineering within the broader context of Systems Engineering.,It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.8288,Students will also improve their ability to understand and solve complex and ill-defined problems.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8422,Students will also improve their ability to understand and solve complex and ill-defined problems.,These include distributed software revision control systems.
0.8499,Students will also improve their ability to understand and solve complex and ill-defined problems.,This course is the first of three core computer science courses on programming.
0.8528,Students will also improve their ability to understand and solve complex and ill-defined problems.,"Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8539,Students will also improve their ability to understand and solve complex and ill-defined problems.,"Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8559,Students will also improve their ability to understand and solve complex and ill-defined problems.,"Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8635,Students will also improve their ability to understand and solve complex and ill-defined problems.,Understand the legal context for protection of software as intellectual property.
0.8743,Students will also improve their ability to understand and solve complex and ill-defined problems.,"Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8744,Students will also improve their ability to understand and solve complex and ill-defined problems.,Understand basic types and the benefits of static typing.
0.8766,Students will also improve their ability to understand and solve complex and ill-defined problems.,"Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8769,Students will also improve their ability to understand and solve complex and ill-defined problems.,"The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8781,Students will also improve their ability to understand and solve complex and ill-defined problems.,"The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.8785,Students will also improve their ability to understand and solve complex and ill-defined problems.,"Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8810,Students will also improve their ability to understand and solve complex and ill-defined problems.,"Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8863,Students will also improve their ability to understand and solve complex and ill-defined problems.,The functional paradigm demonstrates elegant solutions to many programming problems.
0.8934,Students will also improve their ability to understand and solve complex and ill-defined problems.,"Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8989,Students will also improve their ability to understand and solve complex and ill-defined problems.,The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.9023,Students will also improve their ability to understand and solve complex and ill-defined problems.,Describe and apply alternative computational paradigms to simple problems.
0.9123,Students will also improve their ability to understand and solve complex and ill-defined problems.,It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.9138,Students will also improve their ability to understand and solve complex and ill-defined problems.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8124,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8167,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,"Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8190,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,"Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8222,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,"Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8332,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,These include distributed software revision control systems.
0.8341,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,"Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8417,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,Understand basic types and the benefits of static typing.
0.8470,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,The functional paradigm demonstrates elegant solutions to many programming problems.
0.8495,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,Understand the legal context for protection of software as intellectual property.
0.8514,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,This course is the first of three core computer science courses on programming.
0.8548,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,"Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8563,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,"Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8578,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,"Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8589,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,"Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8614,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,"The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8684,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,Describe and apply alternative computational paradigms to simple problems.
0.8743,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,"The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.9055,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.9153,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.9170,Students will also improve their ability to communicate with the multi-disciplinary engineering team and the community at large.,The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.8264,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8290,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,"Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8291,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,"Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8321,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,These include distributed software revision control systems.
0.8343,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,"Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8453,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,"Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8523,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,This course is the first of three core computer science courses on programming.
0.8579,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,Understand basic types and the benefits of static typing.
0.8582,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,The functional paradigm demonstrates elegant solutions to many programming problems.
0.8616,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,"Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8617,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,"Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8628,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,"The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8638,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,"Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8670,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,"Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8737,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,Understand the legal context for protection of software as intellectual property.
0.8777,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,Describe and apply alternative computational paradigms to simple problems.
0.8807,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,"The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.9081,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
0.9127,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.9205,Students will also improve their understanding of and commitment to ethical and professional responsibilities.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.8148,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,"Distinguish language definition from implementation, syntax and parsing from semantics and evaluation."
0.8234,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,These include distributed software revision control systems.
0.8293,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,"Students learn the basic ingredients of imperative programs: mutable variables, sequencing, conditionals, iteration, functions, eager evaluation, and side effects."
0.8320,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,"Students learn the organization of programming languages using types, how programs are evaluated (reduction), functional composition, recursive functions, algebraic data types, pattern matching, parametric polymorphism, higher-order functions."
0.8326,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,"Discuss basic algorithmic analysis for simple algorithms; determine appropriate algorithmic approaches to a problem (brute-force, greedy, divide-and-conquer, recursive backtracking, heuristic, dynamic programming)."
0.8354,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,Understand basic types and the benefits of static typing.
0.8378,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,The functional paradigm demonstrates elegant solutions to many programming problems.
0.8425,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,This course is the first of three core computer science courses on programming.
0.8432,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,"Discuss, use, and apply the fundamentals of data structures, algorithms, and design; create, implement, and debug algorithms for solving simple problems, including recursively, using divide-and-conquer, and via decomposition."
0.8516,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,Understand the legal context for protection of software as intellectual property.
0.8517,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,"Apply fundamental programming concepts, using a functional programming language, to solve simple problems."
0.8520,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,"Data structures and algorithms, the key concepts at the core of computer science, receive their first treatment in this course. The course addresses both functional and imperative programming paradigms."
0.8532,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,"The course covers functional programming in depth, developing the core idea of functions operating on data structures."
0.8560,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,"Describe, understand and evolve programs, via documentation, testing, and debugging."
0.8579,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,"Students also gain exposure to structural induction and proof, introduction to asymptotic analysis of basic data structures, abstract data types, modules, laziness, and streams."
0.8633,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,Describe and apply alternative computational paradigms to simple problems.
0.8707,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,"The course also introduces imperative programming as an alternative paradigm to functional programming, highlighting similarities and contrasting differences."
0.9010,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,The course also introduces students to standard productivity tools for software development that will be used throughout the course and remainder of the computer science degree.
0.9022,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,"The Advanced version of this course covers these topics in more depth, allowing students to deepen their understanding and experience."
0.9030,Students will also improve their ability to function as an individual and as a team leader and member in multi-disciplinary and multi-cultural teams.,It introduces students to the field of computer science as a discipline for solving problems through computation and provides the foundation for more advanced courses on programming and software development.
